# Project 1
building a Flask app that calculates word-frequency
pairs based on the text from a given url

- This is a full-stack tutorial

## pivotal tracker
### welcome to pivotal tracker
- created the various chores to the project


# 1. Part One: Set up a local development environment and then deploy both a staging and a production environment on Heroku. (current)
**start 1 here**

### tasks
1. project setup

- initialised git
- cloned py-ex repo
- moved to py-ex
- `git checkout setting_up`
- `git add *`

- set up virtual enviroment
`virtualenv env`
- activate virtual enviroment(windows)
`source env/Scripts/activate`

- install flask
- test flask by hello world


2. Heroku setup

- install guicorn==19.4.5
- pip freeze > requirements.txt

# heroku bug.

- could not push app to heroku
**soloution**
- created the various apps
- cloned them on different location

3. staging/production workflow

- made changes to stage only
This staging/production workflow allows us to make changes, show things to clients, experiment, etc. - all within a sandboxed server without causing any changes to the live production site that users are, well, using.


4. config setting
The last thing that we’re going to do is set up different config environments for our app. Often there are things that are going to be different between your local, staging, and production setups. You’ll want to connect to different databases, have different AWS keys, etc. Let’s set up a config file to deal with the different environments.
- `touch config.py`
With our config file we’re going to borrow a bit from how Django’s config is set up. We’ll have a base config class that the other config classes inherit from. Then we’ll import the appropriate config class as needed.

```
import os
basedir = os.path.abspath(os.path.dirname(__file__))


class Config(object):
    DEBUG = False
    TESTING = False
    CSRF_ENABLED = True
    SECRET_KEY = 'this-really-needs-to-be-changed'


class ProductionConfig(Config):
    DEBUG = False


class StagingConfig(Config):
    DEVELOPMENT = True
    DEBUG = True


class TestingConfig(config):
    TESTING = True
```

We imported `os` and then set the `basedir` variable as a relative path from any place we call it to this file. 
We then set up a `base Config()` class with some basic setup that our other config classes inherit from. 
Now we’ll be able to import the appropriate config class based on the current environment. 
Thus, we can use environment variables to choose which settings we’re going to use based on the environment 
- e.g., local, staging, production.

## Local Settings

To set up our application with environment variables, we’re going to use autoenv. 
This program allows us to set commands that will run every time we cd into our directory. 
In order to use it, we will need to install it globally. 
First, exit out of your virtual environment in the terminal, install autoenv, then and add a .env file:

```
deactivate

pip install autoenv

touch .env
```
next, in your `.env` file add the following
```
# windows flavour on unix is source env/bin/activate
source env/Scripts/activate
export APP_SETTING="config.DevelopmentConfig"

```
run the following to update then refresh your *.bashrc*
`echo "source `which activate.sh`" >> ~/.bashrc`

`source ~/.bashrc`

## Heroku settings
Similary we're going to set enviroment variables on Heroku

- for staging
`heroku config:set APP_SETTINGS=config.StagingConfig --remote stage`

-for production
`heroku config:set APP_SETTINGS=config.ProductionConfig --remote pro`

To make sure that we use the right environment change app.py:
```
import os
from flask import Flask


app = Flask(__name__)
app.config.from_object(os.environ['APP_SETTING'])


@app.route('/')
def hello():
    return 'Hello world!'


@app.route('/<name>')
def name(name):
    return name


if __name__ == '__main__':
    app.run()
```
**explanation**
- We imported `os` and used the `os.environ` method to import the appropriate` APP_SETTINGS` variables,
 depending on our environment. 
- We then set up the config in our app with the `app.config.from_object` method


### commit and push changes 
- `git push stage master`
- `git push pro master`

# bug python 3.6.5 not supported ##fixed by changinging runtime.txt to python-3.6.6


2. Part Two: Set up a PostgreSQL database along with SQLAlchemy and Alembic to handle migrations.

3. Part Three: Add in the back-end logic to scrape and then process the word counts from a webpage using the requests, BeautifulSoup, and Natural Language Toolkit (NLTK) libraries.

4. Part Four: Implement a Redis task queue to handle the text processing.

5. Part Five: Set up Angular on the front-end to continuously poll the back-end to see if the request is done processing.

6. Part Six: Push to the staging server on Heroku - setting up Redis and detailing how to run two processes (web and worker) on a single Dyno.

7. Part Seven: Update the front-end to make it more user-friendly.

8. Part Eight: Create a custom Angular Directive to display a frequency distribution chart using JavaScript and D3.

